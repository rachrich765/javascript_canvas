<!DOCTYPE html>
<html>
<body>
	<style>
 canvas {
      border: #333 10px solid;
    }
  </style>
<canvas id="myCanvas"></canvas>
<!-- create color picker -->
<input type="color" value="#E03232" id="cp">


<script>
	var canvasPos = getPosition(canvas);
	var mouseX = 0;
	var mouseY = 0;
	var color_val = "red";
	var pen_width = 1;
	var touchX,touchY;
	var canvas = document.querySelector("#myCanvas");
	var ctx = canvas.getContext("2d");

	c = document.querySelector("#cp");
	console.log(c);


	
	// adjust canvas size to size of screen
    window.addEventListener('resize', resizeCanvas, false);
    // adjust canvas size when the orientation of the mobile device is changed
    window.addEventListener('orientationchange', resizeCanvas, false);
    resizeCanvas(); 
      function resizeCanvas() {
        canvas.width = window.innerWidth*0.80;
        canvas.height = window.innerHeight*0.80;
      }

	canvas.addEventListener('touchstart', sketchpad_touchStart, false);
    canvas.addEventListener('touchmove', sketchpad_touchMove, false);
		 // Draw something when a touch start is detected
    function sketchpad_touchStart() {
        // Update the touch co-ordinates
        getTouchPos();

        ctx.arc(touchX, touchY, 5, 0, 2 * Math.PI, true);
        // Prevents an additional mousedown event being triggered
        event.preventDefault();
    }

    // Draw something and prevent the default scrolling when touch movement is detected
    function sketchpad_touchMove(e) { 
        // Update the touch coordinates
        getTouchPos(e);

        // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.
        ctx.arc(touchX, touchY, 5, 0, 2 * Math.PI, true);
		ctx.fill();

        // Prevent a scrolling action as a result of this touchmove triggering.
        event.preventDefault();
    }

    function getTouchPos(e) {
    	var touch = e.touches; 
    	touchX=touch.pageX-touch.target.offsetLeft;
    	touchY=touch.pageY-touch.target.offsetTop;
    }


// clear with phone rotation
window.addEventListener('orientationchange', clear_mobile, false);
function clear_mobile(e){
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	// set color back to red
	color_val = "red";
}

// clear with space bar
window.addEventListener('keydown', clear_desktop, false);
function clear_desktop(e){
	if (e.keyCode === 32){
		ctx.clearRect(0,0, canvas.width, canvas.height); 
		// set color back to red
		color_val = "red";
	}
}

// change color of pen
// with color picker
c.addEventListener("change", get_color2, false);
function get_color2(e){
	color_val = c.value;
	return color_val;
}
// with keys
window.addEventListener("keydown", get_color, false);
function get_color(e){
	var color_key = e.key;
	if (color_key == "b" ) { 
		color_val = "blue";
	}

	if (color_key == "g" ) { 
		color_val = "green";
	}

	if (color_key == "r" ) { 
		color_val = "red";
	}

	if (color_key == "y" ) { 
		color_val = "yellow";
	}
	return color_val;	
}

// increase or decrease size of pen
window.addEventListener("keydown", penSize, false);

function penSize(e) {
	// up arrow pressed
	if (e.keyCode == 38){
		pen_width += 1;
	}
	// down arrow pressed
    if (e.keyCode ==40) {
    	 if (pen_width >= 1){
    	 	pen_width -= 1;
    	 }   
    	}  
    return pen_width;
}

canvas.addEventListener("mousemove", setMousePosition, false);

function setMousePosition(e) {
	mouseX = e.clientX - canvasPos.x;
	mouseY = e.clientY - canvasPos.y;
}

function update(e) {
	ctx.beginPath();
	ctx.arc(mouseX, mouseY, pen_width, 0, 2 * Math.PI, true);
	ctx.fillStyle = color_val;
	ctx.fill();
	requestAnimationFrame(update);
  }

	function getPosition(el) {
  		var xPosition = 0;
  		var yPosition = 0;
// can you pageX and pageY
  		while (el) {
  			xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
  			yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
  			el = el.offsetParent;
  		}

  		return {
  			x: xPosition,
  			y: yPosition
  		};
  	}  
update();
</script>
</body>
</html>