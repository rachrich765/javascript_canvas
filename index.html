<!DOCTYPE html>
<html>
<body>
	<style>
 canvas {
      border: #333 10px solid;
      width: 80%;
      height: 80%;
    }
 
    body {
      padding: 50px;
    }
  </style>
<canvas id="myCanvas">
</canvas>

<script>
	var canvas = document.querySelector("#myCanvas");

	// adjust canvas size to size of screen
    window.addEventListener('resize', resizeCanvas, false);
    // adjust canvas size when the orientation of the mobile device is changed
    window.addEventListener('orientationchange', resizeCanvas, false);
    resizeCanvas(); 
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
    
    var ctx = canvas.getContext("2d");
    ctx.fillStyle ="red"

	var canvasPos = getPosition(canvas);
	var mouseX = 0;
	var mouseY = 0;
	var color_val = 'red'
	var pen_width = 1
	var touchX,touchY;
	canvas.addEventListener('touchstart', sketchpad_touchStart, false);
    canvas.addEventListener('touchmove', sketchpad_touchMove, false);
		 // Draw something when a touch start is detected
    function sketchpad_touchStart() {
        // Update the touch co-ordinates
        getTouchPos();

        drawDot(ctx,touchX,touchY,12);

        // Prevents an additional mousedown event being triggered
        event.preventDefault();
    }

    // Draw something and prevent the default scrolling when touch movement is detected
    function sketchpad_touchMove(e) { 
        // Update the touch co-ordinates
        getTouchPos(e);

        // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.
        drawDot(ctx,touchX,touchY,12); 

        // Prevent a scrolling action as a result of this touchmove triggering.
        event.preventDefault();
    }

    // Get the touch position relative to the top-left of the canvas
    // When we get the raw values of pageX and pageY below, they take into account the scrolling on the page
    // but not the position relative to our target div. We'll adjust them using "target.offsetLeft" and
    // "target.offsetTop" to get the correct values in relation to the top left of the canvas.
    function getTouchPos(e) {
        if (!e)
            var e = event;

        if(e.touches) {
            if (e.touches.length == 1) { // Only deal with one finger
                var touch = e.touches[0]; // Get the information for finger #1
                touchX=touch.pageX-touch.target.offsetLeft;
                touchY=touch.pageY-touch.target.offsetTop;
            }
        }
    }


// clear with phone rotation
canvas.onorientationchange = ctx.clearRect(0, 0, canvas.width, canvas.height);

// clear with space bar
window.addEventListener('keydown', clear_desktop, false);
function clear_desktop(e){
	if (e.keyCode === 32){
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}
	update();
}

// change color of pen
window.addEventListener("keydown", get_color, false);
function get_color(e){

	var color_key = e.key;
	if (color_key == "b" ) { 
		ctx.fillStyle = "blue";
	}

	if (color_key == "g" ) { 
		ctx.fillStyle = "green";
	}

	if (color_key == "r" ) { 
		ctx.fillStyle = "red";
	}

	if (color_key == "y" ) { 
		ctx.fillStyle = "yellow";
	}
	update();
}
	
// increase or decrease size of pen
	window.addEventListener("keydown", penSize, false);
  
function penSize(e) {
    switch(e.keyCode) {
    	// up arrow pressed
        case 38:
        pen_width += 1
        break;
          // down arrow pressed
        case 40:
        if (pen_width >= 1){
        	pen_width -= 1
        	
        }
        break;
    }  
    return pen_width;
     
}       
	canvas.addEventListener("mousemove", setMousePosition, false);


	function setMousePosition(e) {
		mouseX = e.clientX - canvasPos.x;
		mouseY = e.clientY - canvasPos.y;
	}  

	function update(e) {
		ctx.beginPath();
		ctx.arc(mouseX, mouseY, pen_width, 0, 2 * Math.PI, true);
		ctx.fill();
  	requestAnimationFrame(update);
  }
  update();

	function getPosition(el) {
  		var xPosition = 0;
  		var yPosition = 0;

  		while (el) {
  			xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
  			yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
  			el = el.offsetParent;
  		}

  		return {
  			x: xPosition,
  			y: yPosition
  		};
  	}  

</script>
</body>
</html>